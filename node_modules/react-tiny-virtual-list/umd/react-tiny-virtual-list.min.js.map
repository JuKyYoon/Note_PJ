{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///react-tiny-virtual-list.min.js","webpack:///webpack/bootstrap 5e55f1e2a32f66650d75","webpack:///./src/constants.js","webpack:///./src/index.js","webpack:///./src/SizeAndPositionManager.js","webpack:///external {\"root\":\"PropTypes\",\"commonjs2\":\"prop-types\",\"commonjs\":\"prop-types\",\"amd\":\"prop-types\"}","webpack:///external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_3__","__WEBPACK_EXTERNAL_MODULE_4__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","ALIGN_START","ALIGN_CENTER","ALIGN_END","DIRECTION_VERTICAL","SCROLL_CHANGE_OBSERVED","SCROLL_CHANGE_REQUESTED","scrollProp","sizeProp","positionProp","_scrollProp","_sizeProp","_positionProp","DIRECTION_HORIZONTAL","_objectWithoutProperties","obj","keys","target","indexOf","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","writable","setPrototypeOf","__proto__","__WEBPACK_IMPORTED_MODULE_0_react__","__WEBPACK_IMPORTED_MODULE_0_react___default","__WEBPACK_IMPORTED_MODULE_1_prop_types__","__WEBPACK_IMPORTED_MODULE_2__SizeAndPositionManager__","__WEBPACK_IMPORTED_MODULE_3__constants__","VirtualList","_class","_temp2","_extends","assign","arguments","length","source","key","STYLE_WRAPPER","overflow","willChange","WebkitOverflowScrolling","STYLE_INNER","position","width","minHeight","STYLE_ITEM","left","_PureComponent","_temp","_this","_ret","_len","args","Array","_key","apply","concat","sizeAndPositionManager","itemCount","props","itemSizeGetter","_ref","index","getSize","estimatedItemSize","getEstimatedItemSize","state","offset","scrollOffset","scrollToIndex","getOffsetForIndex","scrollChangeReason","_styleCache","_getRef","node","rootNode","handleScroll","e","onScroll","getNodeOffset","setState","componentDidMount","_props","scrollTo","componentWillReceiveProps","nextProps","_props2","itemSize","scrollToAlignment","scrollPropsHaveChanged","itemPropsHaveChanged","updateConfig","recomputeSizes","componentDidUpdate","nextState","undefined","scrollDirection","getUpdatedOffsetForIndex","align","containerSize","targetIndex","isArray","getStyle","_extends2","style","_sizeAndPositionManag","getSizeAndPositionForIndex","size","startIndex","resetItem","render","_extends3","_props3","height","overscanCount","renderItem","_sizeAndPositionManag2","getVisibleRange","start","stop","items","push","a","createElement","ref","getTotalSize","defaultProps","__WEBPACK_IMPORTED_MODULE_0__constants__","SizeAndPositionManager","_itemSizeGetter","_itemCount","_estimatedItemSize","_itemSizeAndPositionData","_lastMeasuredIndex","_ref2","getLastMeasuredIndex","Error","lastMeasuredSizeAndPosition","getSizeAndPositionOfLastMeasuredItem","isNaN","_ref3","_ref3$align","datum","maxOffset","minOffset","idealOffset","totalSize","Math","max","min","_ref4","_findNearestItem","_binarySearch","_ref5","low","high","middle","currentOffset","floor","_exponentialSearch","_ref6","interval","lastMeasuredIndex"],"mappings":"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","file":"react-tiny-virtual-list.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"prop-types\"), require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"prop-types\", \"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"VirtualList\"] = factory(require(\"prop-types\"), require(\"react\"));\n\telse\n\t\troot[\"VirtualList\"] = factory(root[\"PropTypes\"], root[\"React\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_4__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"prop-types\"), require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"prop-types\", \"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"VirtualList\"] = factory(require(\"prop-types\"), require(\"react\"));\n\telse\n\t\troot[\"VirtualList\"] = factory(root[\"PropTypes\"], root[\"React\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_4__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"g\", function() { return ALIGN_START; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"i\", function() { return ALIGN_CENTER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return ALIGN_END; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return DIRECTION_VERTICAL; });\n/* unused harmony export DIRECTION_HORIZONTAL */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return SCROLL_CHANGE_OBSERVED; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return SCROLL_CHANGE_REQUESTED; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return scrollProp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return sizeProp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return positionProp; });\nvar _scrollProp, _sizeProp, _positionProp;\n\nvar ALIGN_START = 'start';\nvar ALIGN_CENTER = 'center';\nvar ALIGN_END = 'end';\nvar DIRECTION_VERTICAL = 'vertical';\nvar DIRECTION_HORIZONTAL = 'horizontal';\nvar SCROLL_CHANGE_OBSERVED = 'observed';\nvar SCROLL_CHANGE_REQUESTED = 'requested';\n\nvar scrollProp = (_scrollProp = {}, _scrollProp[DIRECTION_VERTICAL] = 'scrollTop', _scrollProp[DIRECTION_HORIZONTAL] = 'scrollLeft', _scrollProp);\nvar sizeProp = (_sizeProp = {}, _sizeProp[DIRECTION_VERTICAL] = 'height', _sizeProp[DIRECTION_HORIZONTAL] = 'width', _sizeProp);\nvar positionProp = (_positionProp = {}, _positionProp[DIRECTION_VERTICAL] = 'top', _positionProp[DIRECTION_HORIZONTAL] = 'left', _positionProp);\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__SizeAndPositionManager__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__constants__ = __webpack_require__(0);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return VirtualList; });\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _class, _temp2;\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\nvar STYLE_WRAPPER = { overflow: 'auto', willChange: 'transform', WebkitOverflowScrolling: 'touch' };\nvar STYLE_INNER = { position: 'relative', overflow: 'hidden', width: '100%', minHeight: '100%' };\nvar STYLE_ITEM = { position: 'absolute', left: 0, width: '100%' };\n\nvar VirtualList = (_temp2 = _class = function (_PureComponent) {\n  _inherits(VirtualList, _PureComponent);\n\n  function VirtualList() {\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, VirtualList);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this.sizeAndPositionManager = new __WEBPACK_IMPORTED_MODULE_2__SizeAndPositionManager__[\"a\" /* default */]({\n      itemCount: _this.props.itemCount,\n      itemSizeGetter: function itemSizeGetter(_ref) {\n        var index = _ref.index;\n        return _this.getSize(index);\n      },\n      estimatedItemSize: _this.getEstimatedItemSize()\n    }), _this.state = {\n      offset: _this.props.scrollOffset || _this.props.scrollToIndex != null && _this.getOffsetForIndex(_this.props.scrollToIndex) || 0,\n      scrollChangeReason: __WEBPACK_IMPORTED_MODULE_3__constants__[\"a\" /* SCROLL_CHANGE_REQUESTED */]\n    }, _this._styleCache = {}, _this._getRef = function (node) {\n      _this.rootNode = node;\n    }, _this.handleScroll = function (e) {\n      var onScroll = _this.props.onScroll;\n\n      var offset = _this.getNodeOffset();\n\n      if (offset < 0 || _this.state.offset === offset || e.target !== _this.rootNode) {\n        return;\n      }\n\n      _this.setState({\n        offset: offset,\n        scrollChangeReason: __WEBPACK_IMPORTED_MODULE_3__constants__[\"b\" /* SCROLL_CHANGE_OBSERVED */]\n      });\n\n      if (typeof onScroll === 'function') {\n        onScroll(offset, e);\n      }\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  VirtualList.prototype.componentDidMount = function componentDidMount() {\n    var _props = this.props,\n        scrollOffset = _props.scrollOffset,\n        scrollToIndex = _props.scrollToIndex;\n\n\n    if (scrollOffset != null) {\n      this.scrollTo(scrollOffset);\n    } else if (scrollToIndex != null) {\n      this.scrollTo(this.getOffsetForIndex(scrollToIndex));\n    }\n  };\n\n  VirtualList.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    var _props2 = this.props,\n        estimatedItemSize = _props2.estimatedItemSize,\n        itemCount = _props2.itemCount,\n        itemSize = _props2.itemSize,\n        scrollOffset = _props2.scrollOffset,\n        scrollToAlignment = _props2.scrollToAlignment,\n        scrollToIndex = _props2.scrollToIndex;\n\n    var scrollPropsHaveChanged = nextProps.scrollToIndex !== scrollToIndex || nextProps.scrollToAlignment !== scrollToAlignment;\n    var itemPropsHaveChanged = nextProps.itemCount !== itemCount || nextProps.itemSize !== itemSize || nextProps.estimatedItemSize !== estimatedItemSize;\n\n    if (nextProps.itemCount !== itemCount || nextProps.estimatedItemSize !== estimatedItemSize) {\n      this.sizeAndPositionManager.updateConfig({\n        itemCount: nextProps.itemCount,\n        estimatedItemSize: this.getEstimatedItemSize(nextProps)\n      });\n    }\n\n    if (itemPropsHaveChanged) {\n      this.recomputeSizes();\n    }\n\n    if (nextProps.scrollOffset !== scrollOffset) {\n      this.setState({\n        offset: nextProps.scrollOffset,\n        scrollChangeReason: __WEBPACK_IMPORTED_MODULE_3__constants__[\"a\" /* SCROLL_CHANGE_REQUESTED */]\n      });\n    } else if (scrollPropsHaveChanged || nextProps.scrollToIndex && itemPropsHaveChanged) {\n      this.setState({\n        offset: this.getOffsetForIndex(nextProps.scrollToIndex, nextProps.scrollToAlignment, nextProps.itemCount),\n        scrollChangeReason: __WEBPACK_IMPORTED_MODULE_3__constants__[\"a\" /* SCROLL_CHANGE_REQUESTED */]\n      });\n    }\n  };\n\n  VirtualList.prototype.componentDidUpdate = function componentDidUpdate(nextProps, nextState) {\n    var offset = this.state.offset;\n\n\n    if (nextState.offset !== offset && nextState.scrollChangeReason === __WEBPACK_IMPORTED_MODULE_3__constants__[\"a\" /* SCROLL_CHANGE_REQUESTED */]) {\n      this.scrollTo(offset);\n    }\n  };\n\n  VirtualList.prototype.getEstimatedItemSize = function getEstimatedItemSize() {\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n\n    return props.estimatedItemSize || typeof props.itemSize === \"number\" && props.itemSize || 50;\n  };\n\n  VirtualList.prototype.getNodeOffset = function getNodeOffset() {\n    var scrollDirection = this.props.scrollDirection;\n\n    return this.rootNode[__WEBPACK_IMPORTED_MODULE_3__constants__[\"c\" /* scrollProp */][scrollDirection]];\n  };\n\n  VirtualList.prototype.scrollTo = function scrollTo(value) {\n    var scrollDirection = this.props.scrollDirection;\n\n    this.rootNode[__WEBPACK_IMPORTED_MODULE_3__constants__[\"c\" /* scrollProp */][scrollDirection]] = value;\n  };\n\n  VirtualList.prototype.getOffsetForIndex = function getOffsetForIndex(index) {\n    var scrollToAlignment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.props.scrollToAlignment;\n    var itemCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.props.itemCount;\n    var scrollDirection = this.props.scrollDirection;\n\n\n    if (index < 0 || index >= itemCount) {\n      index = 0;\n    }\n\n    return this.sizeAndPositionManager.getUpdatedOffsetForIndex({\n      align: scrollToAlignment,\n      containerSize: this.props[__WEBPACK_IMPORTED_MODULE_3__constants__[\"d\" /* sizeProp */][scrollDirection]],\n      targetIndex: index\n    });\n  };\n\n  VirtualList.prototype.getSize = function getSize(index) {\n    var itemSize = this.props.itemSize;\n\n\n    if (typeof itemSize === 'function') {\n      return itemSize(index);\n    }\n\n    return Array.isArray(itemSize) ? itemSize[index] : itemSize;\n  };\n\n  VirtualList.prototype.getStyle = function getStyle(index) {\n    var _extends2;\n\n    var style = this._styleCache[index];\n    if (style) {\n      return style;\n    }\n\n    var scrollDirection = this.props.scrollDirection;\n\n    var _sizeAndPositionManag = this.sizeAndPositionManager.getSizeAndPositionForIndex(index),\n        size = _sizeAndPositionManag.size,\n        offset = _sizeAndPositionManag.offset;\n\n    return this._styleCache[index] = _extends({}, STYLE_ITEM, (_extends2 = {}, _extends2[__WEBPACK_IMPORTED_MODULE_3__constants__[\"d\" /* sizeProp */][scrollDirection]] = size, _extends2[__WEBPACK_IMPORTED_MODULE_3__constants__[\"e\" /* positionProp */][scrollDirection]] = offset, _extends2));\n  };\n\n  VirtualList.prototype.recomputeSizes = function recomputeSizes() {\n    var startIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n    this._styleCache = {};\n    this.sizeAndPositionManager.resetItem(startIndex);\n  };\n\n  VirtualList.prototype.render = function render() {\n    var _extends3;\n\n    /* eslint-disable no-unused-vars */\n    var _props3 = this.props,\n        estimatedItemSize = _props3.estimatedItemSize,\n        height = _props3.height,\n        overscanCount = _props3.overscanCount,\n        renderItem = _props3.renderItem,\n        itemCount = _props3.itemCount,\n        itemSize = _props3.itemSize,\n        scrollDirection = _props3.scrollDirection,\n        scrollOffset = _props3.scrollOffset,\n        scrollToIndex = _props3.scrollToIndex,\n        scrollToAlignment = _props3.scrollToAlignment,\n        style = _props3.style,\n        width = _props3.width,\n        props = _objectWithoutProperties(_props3, ['estimatedItemSize', 'height', 'overscanCount', 'renderItem', 'itemCount', 'itemSize', 'scrollDirection', 'scrollOffset', 'scrollToIndex', 'scrollToAlignment', 'style', 'width']);\n\n    var offset = this.state.offset;\n\n    var _sizeAndPositionManag2 = this.sizeAndPositionManager.getVisibleRange({\n      containerSize: this.props[__WEBPACK_IMPORTED_MODULE_3__constants__[\"d\" /* sizeProp */][scrollDirection]],\n      offset: offset,\n      overscanCount: overscanCount\n    }),\n        start = _sizeAndPositionManag2.start,\n        stop = _sizeAndPositionManag2.stop;\n\n    var items = [];\n\n    for (var index = start; index <= stop; index++) {\n      items.push(renderItem({\n        index: index,\n        style: this.getStyle(index)\n      }));\n    }\n\n    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\n      'div',\n      _extends({ ref: this._getRef }, props, { onScroll: this.handleScroll, style: _extends({}, STYLE_WRAPPER, style, { height: height, width: width }) }),\n      __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\n        'div',\n        { style: _extends({}, STYLE_INNER, (_extends3 = {}, _extends3[__WEBPACK_IMPORTED_MODULE_3__constants__[\"d\" /* sizeProp */][scrollDirection]] = this.sizeAndPositionManager.getTotalSize(), _extends3)) },\n        items\n      )\n    );\n  };\n\n  return VirtualList;\n}(__WEBPACK_IMPORTED_MODULE_0_react__[\"PureComponent\"]), _class.defaultProps = {\n  overscanCount: 3,\n  scrollDirection: __WEBPACK_IMPORTED_MODULE_3__constants__[\"f\" /* DIRECTION_VERTICAL */],\n  width: '100%'\n}, _temp2);\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants__ = __webpack_require__(0);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return SizeAndPositionManager; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/* Forked from react-virtualized ðŸ’– */\n\n\nvar SizeAndPositionManager = function () {\n  function SizeAndPositionManager(_ref) {\n    var itemCount = _ref.itemCount,\n        itemSizeGetter = _ref.itemSizeGetter,\n        estimatedItemSize = _ref.estimatedItemSize;\n\n    _classCallCheck(this, SizeAndPositionManager);\n\n    this._itemSizeGetter = itemSizeGetter;\n    this._itemCount = itemCount;\n    this._estimatedItemSize = estimatedItemSize;\n\n    // Cache of size and position data for items, mapped by item index.\n    this._itemSizeAndPositionData = {};\n\n    // Measurements for items up to this index can be trusted; items afterward should be estimated.\n    this._lastMeasuredIndex = -1;\n  }\n\n  SizeAndPositionManager.prototype.updateConfig = function updateConfig(_ref2) {\n    var itemCount = _ref2.itemCount,\n        estimatedItemSize = _ref2.estimatedItemSize;\n\n    this._itemCount = itemCount;\n    this._estimatedItemSize = estimatedItemSize;\n  };\n\n  SizeAndPositionManager.prototype.getLastMeasuredIndex = function getLastMeasuredIndex() {\n    return this._lastMeasuredIndex;\n  };\n\n  /**\n   * This method returns the size and position for the item at the specified index.\n   * It just-in-time calculates (or used cached values) for items leading up to the index.\n   */\n\n\n  SizeAndPositionManager.prototype.getSizeAndPositionForIndex = function getSizeAndPositionForIndex(index) {\n    if (index < 0 || index >= this._itemCount) {\n      throw Error('Requested index ' + index + ' is outside of range 0..' + this._itemCount);\n    }\n\n    if (index > this._lastMeasuredIndex) {\n      var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n      var offset = lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size;\n\n      for (var i = this._lastMeasuredIndex + 1; i <= index; i++) {\n        var size = this._itemSizeGetter({ index: i });\n\n        if (size == null || isNaN(size)) {\n          throw Error('Invalid size returned for index ' + i + ' of value ' + size);\n        }\n\n        this._itemSizeAndPositionData[i] = {\n          offset: offset,\n          size: size\n        };\n\n        offset += size;\n      }\n\n      this._lastMeasuredIndex = index;\n    }\n\n    return this._itemSizeAndPositionData[index];\n  };\n\n  SizeAndPositionManager.prototype.getSizeAndPositionOfLastMeasuredItem = function getSizeAndPositionOfLastMeasuredItem() {\n    return this._lastMeasuredIndex >= 0 ? this._itemSizeAndPositionData[this._lastMeasuredIndex] : { offset: 0, size: 0 };\n  };\n\n  /**\n  * Total size of all items being measured.\n  * This value will be completedly estimated initially.\n  * As items as measured the estimate will be updated.\n  */\n\n\n  SizeAndPositionManager.prototype.getTotalSize = function getTotalSize() {\n    var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n\n    return lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size + (this._itemCount - this._lastMeasuredIndex - 1) * this._estimatedItemSize;\n  };\n\n  /**\n   * Determines a new offset that ensures a certain item is visible, given the alignment.\n   *\n   * @param align Desired alignment within container; one of \"start\" (default), \"center\", or \"end\"\n   * @param containerSize Size (width or height) of the container viewport\n   * @return Offset to use to ensure the specified item is visible\n   */\n\n\n  SizeAndPositionManager.prototype.getUpdatedOffsetForIndex = function getUpdatedOffsetForIndex(_ref3) {\n    var _ref3$align = _ref3.align,\n        align = _ref3$align === undefined ? __WEBPACK_IMPORTED_MODULE_0__constants__[\"g\" /* ALIGN_START */] : _ref3$align,\n        containerSize = _ref3.containerSize,\n        targetIndex = _ref3.targetIndex;\n\n    if (containerSize <= 0) {\n      return 0;\n    }\n\n    var datum = this.getSizeAndPositionForIndex(targetIndex);\n    var maxOffset = datum.offset;\n    var minOffset = maxOffset - containerSize + datum.size;\n\n    var idealOffset = void 0;\n\n    switch (align) {\n      case __WEBPACK_IMPORTED_MODULE_0__constants__[\"h\" /* ALIGN_END */]:\n        idealOffset = minOffset;\n        break;\n      case __WEBPACK_IMPORTED_MODULE_0__constants__[\"i\" /* ALIGN_CENTER */]:\n        idealOffset = maxOffset - (containerSize - datum.size) / 2;\n        break;\n      default:\n        idealOffset = maxOffset;\n        break;\n    }\n\n    var totalSize = this.getTotalSize();\n\n    return Math.max(0, Math.min(totalSize - containerSize, idealOffset));\n  };\n\n  SizeAndPositionManager.prototype.getVisibleRange = function getVisibleRange(_ref4) {\n    var containerSize = _ref4.containerSize,\n        offset = _ref4.offset,\n        overscanCount = _ref4.overscanCount;\n\n    var totalSize = this.getTotalSize();\n\n    if (totalSize === 0) {\n      return {};\n    }\n\n    var maxOffset = offset + containerSize;\n    var start = this._findNearestItem(offset);\n    var stop = start;\n\n    var datum = this.getSizeAndPositionForIndex(start);\n    offset = datum.offset + datum.size;\n\n    while (offset < maxOffset && stop < this._itemCount - 1) {\n      stop++;\n      offset += this.getSizeAndPositionForIndex(stop).size;\n    }\n\n    if (overscanCount) {\n      start = Math.max(0, start - overscanCount);\n      stop = Math.min(stop + overscanCount, this._itemCount - 1);\n    }\n\n    return {\n      start: start,\n      stop: stop\n    };\n  };\n\n  /**\n   * Clear all cached values for items after the specified index.\n   * This method should be called for any item that has changed its size.\n   * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionForIndex() is called.\n   */\n\n\n  SizeAndPositionManager.prototype.resetItem = function resetItem(index) {\n    this._lastMeasuredIndex = Math.min(this._lastMeasuredIndex, index - 1);\n  };\n\n  SizeAndPositionManager.prototype._binarySearch = function _binarySearch(_ref5) {\n    var low = _ref5.low,\n        high = _ref5.high,\n        offset = _ref5.offset;\n\n    var middle = void 0;\n    var currentOffset = void 0;\n\n    while (low <= high) {\n      middle = low + Math.floor((high - low) / 2);\n      currentOffset = this.getSizeAndPositionForIndex(middle).offset;\n\n      if (currentOffset === offset) {\n        return middle;\n      } else if (currentOffset < offset) {\n        low = middle + 1;\n      } else if (currentOffset > offset) {\n        high = middle - 1;\n      }\n    }\n\n    if (low > 0) {\n      return low - 1;\n    }\n  };\n\n  SizeAndPositionManager.prototype._exponentialSearch = function _exponentialSearch(_ref6) {\n    var index = _ref6.index,\n        offset = _ref6.offset;\n\n    var interval = 1;\n\n    while (index < this._itemCount && this.getSizeAndPositionForIndex(index).offset < offset) {\n      index += interval;\n      interval *= 2;\n    }\n\n    return this._binarySearch({\n      high: Math.min(index, this._itemCount - 1),\n      low: Math.floor(index / 2),\n      offset: offset\n    });\n  };\n\n  /**\n   * Searches for the item (index) nearest the specified offset.\n   *\n   * If no exact match is found the next lowest item index will be returned.\n   * This allows partially visible items (with offsets just before/above the fold) to be visible.\n   */\n\n\n  SizeAndPositionManager.prototype._findNearestItem = function _findNearestItem(offset) {\n    if (isNaN(offset)) {\n      throw Error('Invalid offset ' + offset + ' specified');\n    }\n\n    // Our search algorithms find the nearest match at or below the specified offset.\n    // So make sure the offset is at least 0 or no match will be found.\n    offset = Math.max(0, offset);\n\n    var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n    var lastMeasuredIndex = Math.max(0, this._lastMeasuredIndex);\n\n    if (lastMeasuredSizeAndPosition.offset >= offset) {\n      // If we've already measured items within this range just use a binary search as it's faster.\n      return this._binarySearch({\n        high: lastMeasuredIndex,\n        low: 0,\n        offset: offset\n      });\n    } else {\n      // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n      // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n      // The overall complexity for this approach is O(log n).\n      return this._exponentialSearch({\n        index: lastMeasuredIndex,\n        offset: offset\n      });\n    }\n  };\n\n  return SizeAndPositionManager;\n}();\n\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_4__;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(1);\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// react-tiny-virtual-list.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 5e55f1e2a32f66650d75","export const ALIGN_START = 'start';\nexport const ALIGN_CENTER = 'center';\nexport const ALIGN_END = 'end';\nexport const DIRECTION_VERTICAL = 'vertical';\nexport const DIRECTION_HORIZONTAL = 'horizontal';\nexport const SCROLL_CHANGE_OBSERVED = 'observed';\nexport const SCROLL_CHANGE_REQUESTED = 'requested';\n\nexport const scrollProp = {\n  [DIRECTION_VERTICAL]: 'scrollTop',\n  [DIRECTION_HORIZONTAL]: 'scrollLeft',\n};\nexport const sizeProp = {\n  [DIRECTION_VERTICAL]: 'height',\n  [DIRECTION_HORIZONTAL]: 'width',\n};\nexport const positionProp = {\n  [DIRECTION_VERTICAL]: 'top',\n  [DIRECTION_HORIZONTAL]: 'left',\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/constants.js","import React, {PureComponent} from 'react';\nimport PropTypes from 'prop-types';\nimport SizeAndPositionManager from './SizeAndPositionManager';\nimport {\n  ALIGN_CENTER,\n  ALIGN_END,\n  ALIGN_START,\n  DIRECTION_VERTICAL,\n  DIRECTION_HORIZONTAL,\n  SCROLL_CHANGE_OBSERVED,\n  SCROLL_CHANGE_REQUESTED,\n  positionProp,\n  scrollProp,\n  sizeProp,\n} from './constants';\n\nconst STYLE_WRAPPER = {overflow: 'auto', willChange: 'transform', WebkitOverflowScrolling: 'touch'};\nconst STYLE_INNER = {position: 'relative', overflow: 'hidden', width: '100%', minHeight: '100%'};\nconst STYLE_ITEM = {position: 'absolute', left: 0, width: '100%'};\n\nexport default class VirtualList extends PureComponent {\n  static defaultProps = {\n    overscanCount: 3,\n    scrollDirection: DIRECTION_VERTICAL,\n    width: '100%',\n  };\n  static propTypes = {\n    estimatedItemSize: PropTypes.number,\n    height: PropTypes.number.isRequired,\n    itemCount: PropTypes.number.isRequired,\n    itemSize: PropTypes.oneOfType([PropTypes.number, PropTypes.array, PropTypes.func]).isRequired,\n    overscanCount: PropTypes.number,\n    renderItem: PropTypes.func.isRequired,\n    scrollOffset: PropTypes.number,\n    scrollToIndex: PropTypes.number,\n    scrollToAlignment: PropTypes.oneOf([ALIGN_START, ALIGN_CENTER, ALIGN_END]),\n    scrollDirection: PropTypes.oneOf([DIRECTION_HORIZONTAL, DIRECTION_VERTICAL]).isRequired,\n    width: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  }\n\n  sizeAndPositionManager = new SizeAndPositionManager({\n    itemCount: this.props.itemCount,\n    itemSizeGetter: ({index}) => this.getSize(index),\n    estimatedItemSize: this.getEstimatedItemSize(),\n  });\n\n  state = {\n    offset: (\n      this.props.scrollOffset ||\n      this.props.scrollToIndex != null && this.getOffsetForIndex(this.props.scrollToIndex) ||\n      0\n    ),\n    scrollChangeReason: SCROLL_CHANGE_REQUESTED,\n  };\n\n  _styleCache = {};\n\n  _getRef = node => {\n    this.rootNode = node;\n  };\n\n  componentDidMount() {\n    const {scrollOffset, scrollToIndex} = this.props;\n\n    if (scrollOffset != null) {\n      this.scrollTo(scrollOffset);\n    } else if (scrollToIndex != null) {\n      this.scrollTo(this.getOffsetForIndex(scrollToIndex));\n    }\n  }\n\n  componentWillReceiveProps(nextProps) {\n    const {\n      estimatedItemSize,\n      itemCount,\n      itemSize,\n      scrollOffset,\n      scrollToAlignment,\n      scrollToIndex,\n    } = this.props;\n    const scrollPropsHaveChanged = (\n      nextProps.scrollToIndex !== scrollToIndex ||\n      nextProps.scrollToAlignment !== scrollToAlignment\n    );\n    const itemPropsHaveChanged = (\n      nextProps.itemCount !== itemCount ||\n      nextProps.itemSize !== itemSize ||\n      nextProps.estimatedItemSize !== estimatedItemSize\n    );\n\n    if (\n      nextProps.itemCount !== itemCount ||\n      nextProps.estimatedItemSize !== estimatedItemSize\n    ) {\n      this.sizeAndPositionManager.updateConfig({\n        itemCount: nextProps.itemCount,\n        estimatedItemSize: this.getEstimatedItemSize(nextProps),\n      });\n    }\n\n    if (itemPropsHaveChanged) {\n      this.recomputeSizes();\n    }\n\n    if (nextProps.scrollOffset !== scrollOffset) {\n      this.setState({\n        offset: nextProps.scrollOffset,\n        scrollChangeReason: SCROLL_CHANGE_REQUESTED,\n      });\n    } else if (\n      scrollPropsHaveChanged ||\n      nextProps.scrollToIndex && itemPropsHaveChanged\n    ) {\n      this.setState({\n        offset: this.getOffsetForIndex(nextProps.scrollToIndex, nextProps.scrollToAlignment, nextProps.itemCount),\n        scrollChangeReason: SCROLL_CHANGE_REQUESTED,\n      });\n    }\n  }\n\n  componentDidUpdate(nextProps, nextState) {\n    const {offset} = this.state;\n\n    if (nextState.offset !== offset && nextState.scrollChangeReason === SCROLL_CHANGE_REQUESTED) {\n      this.scrollTo(offset);\n    }\n  }\n\n  handleScroll = e => {\n    const {onScroll} = this.props;\n    const offset = this.getNodeOffset();\n\n    if (offset < 0 || this.state.offset === offset || e.target !== this.rootNode) {\n      return;\n    }\n\n    this.setState({\n      offset,\n      scrollChangeReason: SCROLL_CHANGE_OBSERVED,\n    });\n\n    if (typeof onScroll === 'function') {\n      onScroll(offset, e);\n    }\n  };\n\n  getEstimatedItemSize(props = this.props) {\n    return props.estimatedItemSize || typeof props.itemSize === \"number\" && props.itemSize || 50;\n  }\n\n  getNodeOffset() {\n    const {scrollDirection} = this.props;\n    return this.rootNode[scrollProp[scrollDirection]];\n  }\n\n  scrollTo(value) {\n    const {scrollDirection} = this.props;\n    this.rootNode[scrollProp[scrollDirection]] = value;\n  }\n\n  getOffsetForIndex(index, scrollToAlignment = this.props.scrollToAlignment, itemCount = this.props.itemCount) {\n    const {scrollDirection} = this.props;\n\n    if (index < 0 || index >= itemCount) {\n      index = 0;\n    }\n\n    return this.sizeAndPositionManager.getUpdatedOffsetForIndex({\n      align: scrollToAlignment,\n      containerSize: this.props[sizeProp[scrollDirection]],\n      targetIndex: index,\n    });\n  }\n\n  getSize(index) {\n    const {itemSize} = this.props;\n\n    if (typeof itemSize === 'function') { return itemSize(index); }\n\n    return Array.isArray(itemSize) ? itemSize[index] : itemSize;\n  }\n\n  getStyle(index) {\n    const style = this._styleCache[index];\n    if (style) { return style; }\n\n    const {scrollDirection} = this.props;\n    const {size, offset} = this.sizeAndPositionManager.getSizeAndPositionForIndex(index);\n\n    return this._styleCache[index] = {\n      ...STYLE_ITEM,\n      [sizeProp[scrollDirection]]: size,\n      [positionProp[scrollDirection]]: offset,\n    };\n  }\n\n  recomputeSizes(startIndex = 0) {\n    this._styleCache = {};\n    this.sizeAndPositionManager.resetItem(startIndex);\n  }\n\n  render() {\n    /* eslint-disable no-unused-vars */\n    const {\n      estimatedItemSize,\n      height,\n      overscanCount,\n      renderItem,\n      itemCount,\n      itemSize,\n      scrollDirection,\n      scrollOffset,\n      scrollToIndex,\n      scrollToAlignment,\n      style,\n      width,\n      ...props\n    } = this.props;\n    const {offset} = this.state;\n    const {start, stop} = this.sizeAndPositionManager.getVisibleRange({\n      containerSize: this.props[sizeProp[scrollDirection]],\n      offset,\n      overscanCount,\n    });\n    const items = [];\n\n    for (let index = start; index <= stop; index++) {\n      items.push(renderItem({\n        index,\n        style: this.getStyle(index),\n      }));\n    }\n\n    return (\n      <div ref={this._getRef} {...props} onScroll={this.handleScroll} style={{...STYLE_WRAPPER, ...style, height, width}}>\n        <div style={{...STYLE_INNER, [sizeProp[scrollDirection]]: this.sizeAndPositionManager.getTotalSize()}}>\n          {items}\n        </div>\n      </div>\n    );\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","/* Forked from react-virtualized ðŸ’– */\nimport {ALIGN_START, ALIGN_END, ALIGN_CENTER} from './constants';\n\nexport default class SizeAndPositionManager {\n  constructor({\n    itemCount,\n    itemSizeGetter,\n    estimatedItemSize,\n  }) {\n    this._itemSizeGetter = itemSizeGetter;\n    this._itemCount = itemCount;\n    this._estimatedItemSize = estimatedItemSize;\n\n    // Cache of size and position data for items, mapped by item index.\n    this._itemSizeAndPositionData = {};\n\n    // Measurements for items up to this index can be trusted; items afterward should be estimated.\n    this._lastMeasuredIndex = -1;\n  }\n\n  updateConfig({\n    itemCount,\n    estimatedItemSize,\n  }) {\n    this._itemCount = itemCount;\n    this._estimatedItemSize = estimatedItemSize;\n  }\n\n  getLastMeasuredIndex() {\n    return this._lastMeasuredIndex;\n  }\n\n  /**\n   * This method returns the size and position for the item at the specified index.\n   * It just-in-time calculates (or used cached values) for items leading up to the index.\n   */\n  getSizeAndPositionForIndex(index) {\n    if (index < 0 || index >= this._itemCount) {\n      throw Error(`Requested index ${index} is outside of range 0..${this._itemCount}`);\n    }\n\n    if (index > this._lastMeasuredIndex) {\n      let lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n      let offset = lastMeasuredSizeAndPosition.offset +\n        lastMeasuredSizeAndPosition.size;\n\n      for (var i = this._lastMeasuredIndex + 1; i <= index; i++) {\n        let size = this._itemSizeGetter({index: i});\n\n        if (size == null || isNaN(size)) {\n          throw Error(`Invalid size returned for index ${i} of value ${size}`);\n        }\n\n        this._itemSizeAndPositionData[i] = {\n          offset,\n          size,\n        };\n\n        offset += size;\n      }\n\n      this._lastMeasuredIndex = index;\n    }\n\n    return this._itemSizeAndPositionData[index];\n  }\n\n  getSizeAndPositionOfLastMeasuredItem() {\n    return this._lastMeasuredIndex >= 0\n      ? this._itemSizeAndPositionData[this._lastMeasuredIndex]\n      : {offset: 0, size: 0};\n  }\n\n  /**\n  * Total size of all items being measured.\n  * This value will be completedly estimated initially.\n  * As items as measured the estimate will be updated.\n  */\n  getTotalSize() {\n    const lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n\n    return lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size + (this._itemCount - this._lastMeasuredIndex - 1) * this._estimatedItemSize;\n  }\n\n  /**\n   * Determines a new offset that ensures a certain item is visible, given the alignment.\n   *\n   * @param align Desired alignment within container; one of \"start\" (default), \"center\", or \"end\"\n   * @param containerSize Size (width or height) of the container viewport\n   * @return Offset to use to ensure the specified item is visible\n   */\n  getUpdatedOffsetForIndex({\n    align = ALIGN_START,\n    containerSize,\n    targetIndex,\n  }) {\n    if (containerSize <= 0) {\n      return 0;\n    }\n\n    const datum = this.getSizeAndPositionForIndex(targetIndex);\n    const maxOffset = datum.offset;\n    const minOffset = maxOffset - containerSize + datum.size;\n\n    let idealOffset;\n\n    switch (align) {\n      case ALIGN_END:\n        idealOffset = minOffset;\n        break;\n      case ALIGN_CENTER:\n        idealOffset = maxOffset - (containerSize - datum.size) / 2;\n        break;\n      default:\n        idealOffset = maxOffset;\n        break;\n    }\n\n    const totalSize = this.getTotalSize();\n\n    return Math.max(0, Math.min(totalSize - containerSize, idealOffset));\n  }\n\n  getVisibleRange({containerSize, offset, overscanCount}) {\n    const totalSize = this.getTotalSize();\n\n    if (totalSize === 0) { return {}; }\n\n    const maxOffset = offset + containerSize;\n    let start = this._findNearestItem(offset);\n    let stop = start;\n\n    const datum = this.getSizeAndPositionForIndex(start);\n    offset = datum.offset + datum.size;\n\n    while (offset < maxOffset && stop < this._itemCount - 1) {\n      stop++;\n      offset += this.getSizeAndPositionForIndex(stop).size;\n    }\n\n    if (overscanCount) {\n      start = Math.max(0, start - overscanCount);\n      stop = Math.min(stop + overscanCount, this._itemCount - 1);\n    }\n\n    return {\n      start,\n      stop,\n    };\n  }\n\n  /**\n   * Clear all cached values for items after the specified index.\n   * This method should be called for any item that has changed its size.\n   * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionForIndex() is called.\n   */\n  resetItem(index) {\n    this._lastMeasuredIndex = Math.min(this._lastMeasuredIndex, index - 1);\n  }\n\n  _binarySearch({low, high, offset}) {\n    let middle;\n    let currentOffset;\n\n    while (low <= high) {\n      middle = low + Math.floor((high - low) / 2);\n      currentOffset = this.getSizeAndPositionForIndex(middle).offset;\n\n      if (currentOffset === offset) {\n        return middle;\n      } else if (currentOffset < offset) {\n        low = middle + 1;\n      } else if (currentOffset > offset) {\n        high = middle - 1;\n      }\n    }\n\n    if (low > 0) {\n      return low - 1;\n    }\n  }\n\n  _exponentialSearch({index, offset}) {\n    let interval = 1;\n\n    while (\n      index < this._itemCount &&\n      this.getSizeAndPositionForIndex(index).offset < offset\n    ) {\n      index += interval;\n      interval *= 2;\n    }\n\n    return this._binarySearch({\n      high: Math.min(index, this._itemCount - 1),\n      low: Math.floor(index / 2),\n      offset,\n    });\n  }\n\n  /**\n   * Searches for the item (index) nearest the specified offset.\n   *\n   * If no exact match is found the next lowest item index will be returned.\n   * This allows partially visible items (with offsets just before/above the fold) to be visible.\n   */\n  _findNearestItem(offset) {\n    if (isNaN(offset)) {\n      throw Error(`Invalid offset ${offset} specified`);\n    }\n\n    // Our search algorithms find the nearest match at or below the specified offset.\n    // So make sure the offset is at least 0 or no match will be found.\n    offset = Math.max(0, offset);\n\n    const lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n    const lastMeasuredIndex = Math.max(0, this._lastMeasuredIndex);\n\n    if (lastMeasuredSizeAndPosition.offset >= offset) {\n      // If we've already measured items within this range just use a binary search as it's faster.\n      return this._binarySearch({\n        high: lastMeasuredIndex,\n        low: 0,\n        offset,\n      });\n    } else {\n      // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n      // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n      // The overall complexity for this approach is O(log n).\n      return this._exponentialSearch({\n        index: lastMeasuredIndex,\n        offset,\n      });\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/SizeAndPositionManager.js","module.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"PropTypes\",\"commonjs2\":\"prop-types\",\"commonjs\":\"prop-types\",\"amd\":\"prop-types\"}\n// module id = 3\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_4__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}\n// module id = 4\n// module chunks = 0"],"sourceRoot":""}